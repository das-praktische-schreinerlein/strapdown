/* global jQuery */
(function( $ ) {
  'use strict';

  var _ = {
    analyzeHeader: function  (elem) {
      var header = {},
          jqElem = $(elem)
          ;

      // delete hidden, styles, scripts
      if (jqElem) {
          header.title = jqElem.first()
              .clone()
              .find(':hidden')
              .remove()
              .end()
              .find('script')
              .remove()
              .end()
              .find('style')
              .remove()
              .end()
              .text();
      }

      header.jq = jqElem;
      header.level = elem.tagName[1];  // extract the number from h1,h2, etc.
      header.hash = elem.id;           // generated by marked

      return header;
    },

    buildTocItem: function  (hash, title) {
      // The <li> is to be closed when all his children have been added.
      return '<li><a href="" onclick="$(\'#' + hash + '\').scrollView(); return false;" target="_self">' + title + '</a>';
    },

    generateClosingTags: function (previousLevel, currentLevel) {
      var difference = previousLevel - currentLevel,
          closingTags = ''
          ;

      while (difference--) {
        closingTags += '</ul>';
      }
      closingTags += '</li>';
      return closingTags;
    },

    makeToc: function  (contentEl, settings) {
      var headerLevels = 'h1,h2,h3,h4,h5',
          tocString = '',
          prevLevel
          ;

      contentEl.find(headerLevels).each(function (index, elem) {
        var header = _.analyzeHeader(elem);

        // Building the tag hierarchy
        if (!prevLevel) {
          // Initialization, <ul> tag not needed
        } else if (header.level > prevLevel) {
          tocString += '<ul>';
        } else if (header.level < prevLevel) {
          tocString += _.generateClosingTags(prevLevel, header.level);
        } else {
          tocString += '</li>';
        }

        // add <li>
        tocString += _.buildTocItem(header.hash, header.title, header.level -1);
        prevLevel = header.level;
      });

      tocString += _.generateClosingTags(prevLevel, 1);

      if (settings.toc.topLink) {
        var label = settings.toc.topLink;
//        tocString += '<li><a href="" id="backTop" onlick="' +
//                     '$(\'html,body\').animate({scrollTop:0},0); return false;' +
//                     '"  target="_self">' + label + '</a></li>';
      }

      return tocString;
    }
  };

  $.fn.toc = function (contentEl, settings) {
    if (settings && settings.toc && !settings.toc.disabled) {
      var navbarTocEl = $(settings.toc.dest).first();

      if (!contentEl.length) {
        console.warn('No content available to generate the table of content from. Aborting.');
        return this;
      } else if (! navbarTocEl.length ) {
        console.warn('Unable to find the insertion point for the table of content. Aborting.');
        return this;
      } else {
        navbarTocEl.append($('<ul/>', {
          'class': settings.toc.scrollspy ? 'nav navbar-nav' : '',
          'html': _.makeToc(contentEl.first(), settings)
        }));
        
        // do show only if not hide
        if (! settings.toc.hide) {
            // check for minDeep
            $(navbarTocEl).each(function () {
                var filter = "#" + this.id + " li";
                if ($(filter).length > (settings.toc.minDeep || 0)) {
                    $(this).css("display", "block");
                } else {
                    $(this).css("display", "none");
                }
            });
        }

        if (settings.toc.scrollspy) {
          if ($.fn.scrollspy) {
            setTimeout(function () {
              $('body').scrollspy({
                target: settings.toc.dest,
                offset: settings.toc.scrollspyOffset
              });
            }, 500);
          } else {
            console.warn('boostrap scrollspy is not available.');
          }
        }
      }
    }

    return this;
  };
  
  function hasScroll(el, index, match) {
      var $el = $(el),
          sG = $el.css('overflow'),
          sX = $el.css('overflow-x'),
          sY = $el.css('overflow-y'),
          hidden = 'hidden', // minifiers would like this better
          visible = 'visible',
          scroll = 'scroll',
          axis = match[3]; // regex for filter -> 3 == args to selector

      if (!axis) { // better check than undefined
          //Check both x and y declarations
          if (sX === sY && (sY === hidden || sY === visible)) { //same check but shorter syntax
              return false;
          }
          if (sX === scroll || sY === scroll) { return true; }
          if (sG === hidden || sG === visible) {
              return false;
          }
      } else if (axis === 'x') { // don't mix ifs and switches on the same variable
          if ($el[0].style.width === 'auto') { return false; }
          if (sX === hidden || sX === visible) { return false; }
          if (sX === scroll) { return true; }
          if (sG === hidden || sG === visible) {
              return false;
          }
          return $el.innerWidth() < el.scrollWidth;
      } else if (axis === 'y') {
          if ($el[0].style.height === 'auto') { return false ; }
          if (sY === hidden || sY === visible) { return false; }
          if (sY === scroll) { return true ;}
          if (sG === hidden || sG === visible) {
              return false;
          }
          return $el.innerHeight() < el.scrollHeight;
      }

      //Compare client and scroll dimensions to see if a scrollbar is needed
      return $el.innerHeight() < el.scrollHeight || //make use of potential short circuit
          $el.innerWidth() < el.scrollWidth; //innerHeight is the one you want
  }
  $.expr[':'].hasScrollBar = hasScroll;

  $.fn.scrollView = function () {
      console.log('scrollView for:', this);
      return this.each(function (idx, that) {
          // use the first scrollable element
          var $parent;
          $(that).parents(':hasScrollBar(y)').each(function (idx2, ele) {
              if ($parent) {
                  return;
              }
              if ($(ele)[0].tagName === 'BODY') {
                  // body has problems on ng-page
                  return;
              }
              $parent = $(ele);
          });
          if (!$parent) {
              $parent = $('html, body');
          }
          console.log('scrollView use:', $parent);
          $parent.animate({
              scrollTop: $(that).offset().top
          }, 1000);
      });
  };
}( jQuery ));
